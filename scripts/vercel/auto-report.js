#!/usr/bin/env node

/**
 * Automated Vercel Error Reporter
 * Monitors deployments and sends error reports
 *
 * Usage:
 *   node scripts/vercel/auto-report.js
 *   node scripts/vercel/auto-report.js --slack <webhook-url>
 *   node scripts/vercel/auto-report.js --email <email>
 */

const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs').promises;
const path = require('path');

const execAsync = promisify(exec);

const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
};

const CONFIG = {
  checkInterval: 5 * 60 * 1000, // 5 minutes
  reportDir: path.join(process.cwd(), 'logs', 'vercel-reports'),
  stateFile: path.join(process.cwd(), 'logs', '.vercel-monitor-state.json'),
};

/**
 * Load monitoring state
 */
async function loadState() {
  try {
    const data = await fs.readFile(CONFIG.stateFile, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    return { lastChecked: null, reportedDeployments: [] };
  }
}

/**
 * Save monitoring state
 */
async function saveState(state) {
  await fs.mkdir(path.dirname(CONFIG.stateFile), { recursive: true });
  await fs.writeFile(CONFIG.stateFile, JSON.stringify(state, null, 2));
}

/**
 * Get deployments since last check
 */
async function getRecentDeployments(since) {
  const result = await execAsync('vercel ls --prod').catch(e => ({ stdout: '', stderr: e.message }));
  const lines = result.stdout.split('\n');
  const deployments = [];

  for (const line of lines) {
    const urlMatch = line.match(/(https:\/\/[^\s]+)/);
    const statusMatch = line.match(/(Ready|Error|Canceled|Building)/);

    if (urlMatch && statusMatch) {
      const id = urlMatch[1].match(/([a-z0-9-]+)\.vercel\.app/)?.[1];
      deployments.push({
        url: urlMatch[1],
        id,
        status: statusMatch[1],
      });
    }
  }

  return deployments;
}

/**
 * Analyze deployment for errors
 */
async function analyzeDeployment(deployment) {
  if (deployment.status === 'Ready' || deployment.status === 'Building') {
    return null;
  }

  console.log(`${colors.yellow}Analyzing failed deployment: ${deployment.id}${colors.reset}`);

  const result = await execAsync(`vercel inspect ${deployment.url} --logs`).catch(e => ({
    stdout: '',
    stderr: e.message,
  }));

  const logs = result.stdout;
  const errors = extractErrors(logs);

  if (errors.length === 0) {
    return null;
  }

  return {
    deployment,
    errors,
    logs,
    analyzedAt: new Date().toISOString(),
  };
}

/**
 * Extract errors from logs
 */
function extractErrors(logs) {
  const errors = [];
  const lines = logs.split('\n');

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    if (line.includes('Module not found') || line.includes('Type error:') || line.includes('SyntaxError:')) {
      const errorType = line.includes('Module not found')
        ? 'Module Not Found'
        : line.includes('Type error')
        ? 'Type Error'
        : 'Syntax Error';

      errors.push({
        type: errorType,
        message: line.trim(),
        file: lines[i - 1]?.match(/\.\/(.*)/)?.[1] || 'unknown',
      });
    }
  }

  return errors;
}

/**
 * Generate Markdown report
 */
function generateMarkdownReport(analysis) {
  const { deployment, errors, analyzedAt } = analysis;

  let markdown = `# Build Error Report\n\n`;
  markdown += `**Deployment**: ${deployment.url}\n`;
  markdown += `**Status**: ${deployment.status}\n`;
  markdown += `**Analyzed**: ${analyzedAt}\n\n`;

  markdown += `## Errors Found (${errors.length})\n\n`;

  errors.forEach((error, index) => {
    markdown += `### ${index + 1}. ${error.type}\n\n`;
    markdown += `**File**: \`${error.file}\`\n\n`;
    markdown += `\`\`\`\n${error.message}\n\`\`\`\n\n`;
  });

  markdown += `## Next Steps\n\n`;
  markdown += `1. Review the errors above\n`;
  markdown += `2. Fix the issues in the codebase\n`;
  markdown += `3. Push changes to trigger new deployment\n`;
  markdown += `4. Monitor the new deployment\n\n`;

  markdown += `---\n`;
  markdown += `*Generated by Vercel Auto-Reporter*\n`;

  return markdown;
}

/**
 * Save report to file
 */
async function saveReport(analysis) {
  await fs.mkdir(CONFIG.reportDir, { recursive: true });

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const filename = `report-${analysis.deployment.id}-${timestamp}.md`;
  const filepath = path.join(CONFIG.reportDir, filename);

  const markdown = generateMarkdownReport(analysis);
  await fs.writeFile(filepath, markdown);

  console.log(`${colors.green}âœ“ Report saved: ${filename}${colors.reset}`);

  return filepath;
}

/**
 * Send Slack notification
 */
async function sendSlackNotification(analysis, webhookUrl) {
  const { deployment, errors } = analysis;

  const payload = {
    text: `ðŸš¨ Vercel Deployment Failed`,
    blocks: [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: 'ðŸš¨ Vercel Deployment Failed',
        },
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Deployment:*\n${deployment.id}`,
          },
          {
            type: 'mrkdwn',
            text: `*Status:*\n${deployment.status}`,
          },
          {
            type: 'mrkdwn',
            text: `*Errors:*\n${errors.length}`,
          },
        ],
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*URL:* ${deployment.url}`,
        },
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: '*Errors:*\n' + errors.slice(0, 3).map(e => `â€¢ ${e.type}: \`${e.file}\``).join('\n'),
        },
      },
    ],
  };

  try {
    const response = await fetch(webhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });

    if (response.ok) {
      console.log(`${colors.green}âœ“ Slack notification sent${colors.reset}`);
    } else {
      console.log(`${colors.red}âœ— Failed to send Slack notification${colors.reset}`);
    }
  } catch (error) {
    console.error(`${colors.red}Error sending Slack notification:${colors.reset}`, error.message);
  }
}

/**
 * Monitor loop
 */
async function monitorLoop(options = {}) {
  console.log(`${colors.cyan}Starting Vercel deployment monitor...${colors.reset}\n`);

  let state = await loadState();

  while (true) {
    console.log(`${colors.yellow}[${new Date().toISOString()}] Checking deployments...${colors.reset}`);

    try {
      const deployments = await getRecentDeployments(state.lastChecked);
      const failedDeployments = deployments.filter(
        d => (d.status === 'Error' || d.status === 'Canceled') && !state.reportedDeployments.includes(d.id)
      );

      if (failedDeployments.length > 0) {
        console.log(`${colors.red}Found ${failedDeployments.length} new failed deployment(s)${colors.reset}\n`);

        for (const deployment of failedDeployments) {
          const analysis = await analyzeDeployment(deployment);

          if (analysis) {
            // Save report
            await saveReport(analysis);

            // Send notifications
            if (options.slackWebhook) {
              await sendSlackNotification(analysis, options.slackWebhook);
            }

            // Mark as reported
            state.reportedDeployments.push(deployment.id);
          }
        }
      } else {
        console.log(`${colors.green}âœ“ No new failures${colors.reset}\n`);
      }

      state.lastChecked = new Date().toISOString();
      await saveState(state);
    } catch (error) {
      console.error(`${colors.red}Error during check:${colors.reset}`, error.message);
    }

    // Wait for next check
    await new Promise(resolve => setTimeout(resolve, CONFIG.checkInterval));
  }
}

/**
 * Main function
 */
async function main() {
  const args = process.argv.slice(2);

  const options = {};

  // Parse arguments
  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--slack' && args[i + 1]) {
      options.slackWebhook = args[i + 1];
      i++;
    } else if (args[i] === '--interval' && args[i + 1]) {
      CONFIG.checkInterval = parseInt(args[i + 1]) * 1000;
      i++;
    }
  }

  // Start monitoring
  await monitorLoop(options);
}

if (require.main === module) {
  main().catch(error => {
    console.error(`${colors.red}Fatal error:${colors.reset}`, error);
    process.exit(1);
  });
}

module.exports = {
  analyzeDeployment,
  generateMarkdownReport,
  sendSlackNotification,
};
