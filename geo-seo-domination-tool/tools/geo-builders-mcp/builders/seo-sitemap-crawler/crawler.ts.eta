/* Simple sitemap-first (then discover) crawler
 * Usage: node <OUTPUT_DIR>/crawl-site.ts
 */
import { writeFileSync, mkdirSync } from 'node:fs';
import { existsSync } from 'node:fs';
import { resolve } from 'node:path';

const START_URL = '<%= START_URL %>';
const LIMIT = Number('<%= MAX_URLS %>' || '1000');
const OUTDIR = resolve(process.cwd(), '<%= OUTPUT_DIR %>');
const OUTFILE = resolve(OUTDIR, `crawl-${Date.now()}.json`);

async function fetchText(u: string){ const r = await fetch(u, { headers: { 'user-agent': 'geo-seo-crawler/1.0' }}); if(!r.ok) throw new Error(`${u} -> ${r.status}`); return r.text(); }
function abs(base: string, href: string){ try{ return new URL(href, base).toString(); }catch{ return null; } }

async function parseSitemap(u: string){
  const txt = await fetchText(u);
  const urls = new Set<string>();
  // naive: extract <loc>...</loc>
  for (const m of txt.matchAll(/<loc>(.*?)<\/loc>/gi)){ urls.add(m[1].trim()); }
  return Array.from(urls);
}

async function discover(base: string, seen: Set<string>, queue: string[]){
  const u = queue.shift(); if(!u) return null; if (seen.has(u)) return null; seen.add(u);
  try {
    const html = await fetchText(u);
    for (const m of html.matchAll(/href=["']([^"'#?\s>]+)["']/gi)){
      const link = abs(u, m[1]); if(!link) continue;
      if (link.startsWith(base)) queue.push(link);
      if (queue.length + seen.size >= LIMIT) break;
    }
    return { url: u, ok: true };
  } catch (e:any) { return { url: u, ok: false, error: String(e?.message||e) }; }
}

(async ()=>{
  if (!existsSync(OUTDIR)) mkdirSync(OUTDIR, { recursive: true });
  const base = new URL(START_URL).origin;
  const fromSitemap = START_URL.endsWith('sitemap.xml') ? await parseSitemap(START_URL) : [];
  const initial = fromSitemap.length ? fromSitemap.slice(0, LIMIT) : [START_URL];
  const queue = Array.from(new Set(initial));
  const seen = new Set<string>();
  const visited: any[] = [];

  while ((queue.length + seen.size) && visited.length < LIMIT){
    const item = await discover(base, seen, queue);
    if (item) visited.push(item);
    if (queue.length === 0 && !fromSitemap.length) break;
  }

  const urls = Array.from(seen);
  const report = { startedAt: new Date().toISOString(), base, startUrl: START_URL, limit: LIMIT, count: urls.length, urls, visited };
  writeFileSync(OUTFILE, JSON.stringify(report, null, 2));
  console.log(`âœ“ Wrote ${OUTFILE}`);
})();
