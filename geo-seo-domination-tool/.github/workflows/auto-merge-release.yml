name: Auto Merge Release (Staged)

on:
  workflow_dispatch:
    inputs:
      release_branch:
        description: 'Release branch to aggregate'
        required: true
        default: 'release/geo-mcp-v1'
      target_branch:
        description: 'Final target branch'
        required: true
        default: 'main'
      branches:
        description: 'Feature branches to merge (newline-separated)'
        required: true
        default: |
          feature/build-system-fix
          feature/mcp-call-runner-fix
          feature/mcp-server-core
          feature/selective-apply-from-diff
          feature/rollback-from-backups
          feature/blueprint-saas-starter
          feature/autolink-after-apply
          feature/redis-workers-scale
          feature/supabase-auth-starter
          feature/role-guards-admin-ui
          feature/api-role-guards
          feature/oauth-providers
          feature/stripe-billing-starter
          feature/post-blueprint-autolink-deploy
          feature/deploy-runner
          feature/remote-ssh-deploy
          feature/release-guardrails
          feature/merge-queue

permissions:
  contents: write
  pull-requests: write

jobs:
  staged-merge:
    name: stage-and-queue
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure release branch exists from target
        env:
          REL: ${{ inputs.release_branch }}
          TGT: ${{ inputs.target_branch }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git fetch origin $TGT
          if git ls-remote --heads origin $REL | grep -q $REL; then
            echo "Release branch exists; syncing with target"
            git checkout $REL
            git pull --ff-only origin $REL || true
            git merge --ff-only origin/$TGT || true
            git push origin HEAD:$REL || true
          else
            echo "Creating $REL from $TGT"
            git checkout -b $REL origin/$TGT
            git push -u origin $REL
          fi

      - name: Build list of feature branches
        id: list
        run: |
          echo "branches<<EOF" >> $GITHUB_OUTPUT
          printf "%s\n" "${{ inputs.branches }}" | sed '/^\s*$/d' >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Open/Auto-merge PRs feature -> release
        uses: actions/github-script@v7
        env:
          REL: ${{ inputs.release_branch }}
        with:
          script: |
            const rel = process.env.REL;
            const branches = `${{inputs.branches}}`.split('\n').map(s=>s.trim()).filter(Boolean);
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            async function branchExists(ref){
              try { await github.rest.git.getRef({ owner, repo, ref: `heads/${ref}` }); return true; } catch { return false; }
            }

            async function findOrCreatePR(head, base){
              const prs = await github.rest.pulls.list({ owner, repo, state: 'open', head: `${owner}:${head}`, base });
              if (prs.data.length) return prs.data[0];
              const pr = await github.rest.pulls.create({ owner, repo, head, base, title: `Merge ${head} -> ${base}` });
              return pr.data;
            }

            async function enableAutoMerge(pr){
              try {
                await github.graphql(`mutation($prId:ID!){ enablePullRequestAutoMerge(input:{ pullRequestId:$prId, mergeMethod:SQUASH }){ clientMutationId } }`, { prId: pr.node_id });
              } catch (e) {
                core.warning(`Auto-merge not enabled for #${pr.number}: ${e.message}`);
              }
            }

            for (const head of branches){
              const exists = await branchExists(head);
              if (!exists){ core.info(`Skip: ${head} (no such branch)`); continue; }
              core.info(`Preparing PR: ${head} -> ${rel}`);
              const pr = await findOrCreatePR(head, rel);
              if (pr.draft){ await github.rest.pulls.update({ owner, repo, pull_number: pr.number, draft: false }); }
              // apply labels to help queue visibility
              try { await github.rest.issues.addLabels({ owner, repo, issue_number: pr.number, labels: ['release-queue'] }); } catch {}
              await enableAutoMerge(pr);
            }

      - name: Kick CI with merge queue workflow
        run: echo 'Queue will be driven by branch protections + merge queue on release branch.'

      - name: Open/Auto-merge PR release -> target
        uses: actions/github-script@v7
        env:
          REL: ${{ inputs.release_branch }}
          TGT: ${{ inputs.target_branch }}
        with:
          script: |
            const owner = context.repo.owner; const repo = context.repo.repo;
            const rel = process.env.REL; const tgt = process.env.TGT;
            // ensure open PR
            const prs = await github.rest.pulls.list({ owner, repo, state: 'open', base: tgt, head: `${owner}:${rel}` });
            let pr;
            if (prs.data.length){ pr = prs.data[0]; }
            else { pr = (await github.rest.pulls.create({ owner, repo, base: tgt, head: rel, title: `Release ${rel} -> ${tgt}` })).data; }
            // label + auto-merge
            try { await github.rest.issues.addLabels({ owner, repo, issue_number: pr.number, labels: ['release-pr'] }); } catch {}
            try {
              await github.graphql(`mutation($prId:ID!){ enablePullRequestAutoMerge(input:{ pullRequestId:$prId, mergeMethod:SQUASH }){ clientMutationId } }`, { prId: pr.node_id });
            } catch (e) {
              core.warning(`Auto-merge not enabled for release PR #${pr.number}: ${e.message}`);
            }
            core.notice(`Release PR #${pr.number} ready. Merge Queue/branch protections will merge when checks pass.`)
